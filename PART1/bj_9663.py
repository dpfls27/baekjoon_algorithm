''' 
    체스 속 퀸의 규칙
    : 퀸은 상하좌우, 대각선 방향으로 자유롭게 이동가능 (다른 기물이 막고있지 않는 한)
    
    문제에서 요구한대로 퀸을 놓은 위치를 기준으로 다음 퀸을 놓을 자리를 탐색 해야하므로 DFS이용
    
    깊이 우선 탐색(DFS)
    :루트 노드에서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
    자기 자신을 호출하는 순환 알고리즘의 형태로, 어떤 노드를 방문했었는지 여부를 검사해야 무한루프위험에서 
    벗어날 수 있음 
    1) 탐색의 종료 조건 확인 
    2) 반복문 내에서 제약 조건을 검사 후 가지치기 진행 
    3) 모든 경우의 수를 검토하기 위해 백트래킹 구현 
    
    퀸이 서로를 잡지 못하게 하려면 무조건 하나의 행에는 하나의 퀸이 들어가야함
    현재 하나의 행에 대하여 퀸들의 위치가 같은행렬 혹은 대각선에 있으면 안됨
    즉, 차례대로 하나의 행에 퀸을 하나씩 두면서 조건에 일치하면 해당 열에 말을 두고 다음 행으로 넘어가고, 불일치하면 다음 열을 확인 
    
    
'''
# 해설 참고한 답 
import sys

N = int(sys.stdin.readline())
print("입력 완료")
chess_map = [0]* N # 인덱스 = 행 번호, 배열 값 = 열 번호 
 # row가 행 col이 열 임을 주의 
'''ex) N = 4 일때 
       chess_map = [0,0,0,0] 이말은 [체스판의 첫번째 열, 체스판의 두번째 열, 체스판의 세번째 열, 체스판의 네번째 열 ]
       그래서 chess_map의 인덱스 값이 행의 값이 되는거고 chess_mapr[]의 결과 값이 열이 되는거다 
       즉, 예를 들어 chess_map = [1,3,0,2] 라고 하면
       0행 1열에 퀸 하나, 1행 3열에 퀸하나, 2행 0열에 퀸 하나, 3행 2열에 퀸 하나 이렇게를 의미 (1은 퀸의 위치라고 가정)
       0100
       0001
       1000
       0010
'''

def queen_check(row):
    for before_row in range(row):
        # 같은 열 혹은 같은 대각선 상(|행끼리 뺀 값| = |열끼리 뺀 값| 성립 시) 에 있는 경우면 안됨 그래서 False 반환 
        if (chess_map[row] == chess_map[before_row]) or (abs(chess_map[row] - chess_map[before_row]) == abs(row - before_row)): # abs는 절댓값 만드는 함수
            return False 
    return True


count = 0 # 출력 값 

def DFS(row):
    global count # 출력 값은 전역 변수라서 
    
    if row == N : # 서로 공격할 수 없는 채로 체스판의 마지막 행까지 온거니까 이러면 퀸을 놓는 방법의 수 1 증가 
        count += 1
        
    else: # 마지막 행까지 아직 도착하지 않은 경우 
        for i in range(N):
            chess_map[row] = i # 퀸을 체스판의 한 위치에 확정적으로 놓음을 의미 
            
            if queen_check(row): # 같은 열인지 혹은 대각선인지 아닌지 확인하고 안겹친다고 통과 받으면 
                DFS(row+1) # 다음 행으로 넘어가서 이 과정 다시 반복 


DFS(0) # 0번째 행에 퀸을 어디에 놓을 수 있을지 탐색 시작하겠다는 의미 0행에 두지 않으면 첫번째 퀸이 없는것과 같음 
print(count)
